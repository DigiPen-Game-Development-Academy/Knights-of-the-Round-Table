//Author Brandon Wolenetz

/*TODO:
    
    1. finnish this script
    
    2. maybe change min/max over health to sample curves
    
*/

enum RState {
    Idle,
    Normal,
    Rush,
    AngryRush,
    Dazed,
    Winding
}

class Boss_Rusher_AI : ZilchComponent {
    
    //*****Dependencies*****
    [Dependency] var Health : Health;
    [Dependency] var PathFollow : GenericPathFollowAI;
    [Dependency] var PathFind : EnemyPathFind;
    [Dependency] var RigidBody : RigidBody;
    
    //*****Properties*****
    //how fast to move when in 'normal' state
    [Property] var MovSpeed : Real = 2;
    //how fast to dash
    [Property] var DashSpeed : Real = 7;
    //how fast to angry dash
    [Property] var AngryDashSpeed : Real = 7;
    
    //wind up time before dash at full health
    [Property] var WindUpTimeMax : Real = 1.5;
    //wind up time before dash at no health
    [Property] var WindUpTimeMin : Real = 0.5;
    //how far to travel with normal dash
    [Property] var DashDistance : Real = 7;
    //how long to chase player with angry dash
    [Property] var AngryDashTime : Real = 4;
    //ammount of time to be dazed after running into wall
    [Property] var DazeTime : Real = 4;
    //% of health to switch from dashing to angry dashing (0-1)
    [Property] var AngryDashHealth : Real = 0.25;
    //speed to turn twareds player when angry dashing
    [Property] var AngryTurnSpeed : Real = 10;
    //damage dealt when hit player with dash
    [Property] var DashDamage : Real = 50;
    //damage dealt per second while toutching player
    [Property] var PassiveDamage : Real = 50;
    //time between entering dash state at full health
    [Property] var DashCooldownMax : Real = 6;
    //time between entering dash state at no health
    [Property] var DashCooldownMin : Real = 4;
    //Randomness for time between entering dash states
    [Property] var DashCooldownRand : Real = 0.1;
    //range at whitch to start the boss fight
    [Property] var StartRange : Real = 10;
    //death message if player is defeated by boss using dash
    [Property] var DashDamageMSG : String = "You where run over by a giant rusher!";
    //death message if player is defeated by boss using passive damage
    [Property] var PassiveDamageMSG : String = "Wait...  did that rusher just sit on you?!?";
    
    //*****Variables*****
    //current boss state
    var State : RState = RState.Idle;
    //Timer used for delays and sutch
    var Timer : Real = 0;
    //Random() used for randomness
    var Rand : Random;
    //used to only set dash speed and start pos at start of dash
    var DashOnce : Boolean = false;
    //the start position of a dash
    var DashStart : Real3 = Real3(0);
    //the direction of a dash
    var DashDir : Real3 = Real3(0);
    
    function Initialize(init : CogInitializer) {
        this.Rand = Random();
        Zero.Connect(this.Space, Events.LogicUpdate, this.OnLogicUpdate);
        Zero.Connect(this.Owner, Events.CollisionStarted, this.OnCollisionStarted);
        Zero.Connect(this.Owner, Events.CollisionPersisted, this.OnCollisionPersisted);
    }

    function OnCollisionPersisted(event : CollisionEvent) {
        
        //damage player over time while colliding
        if (event.OtherObject == GlobalVariables.Player) {
            //deal damage to player
            var damage = Damage();
            damage.Damage = this.PassiveDamage * this.Space.TimeSpace.Dt;
            damage.DeathMSG = this.PassiveDamageMSG;
            GlobalVariables.Player.DispatchEvent(Events.Damage, damage);
        }
        
    }

    function OnCollisionStarted(event : CollisionEvent) {
        
        //if dashing
        if (this.State == RState.Rush || this.State == RState.AngryRush) {
            
            if (event.OtherObject == GlobalVariables.Player) {  //run into player
                
                //set state to normal
                this.State = RState.Normal;
                //set timer for dash cooldown
                this.Timer = Math.Lerp(this.DashCooldownMin, this.DashCooldownMax, this.Health.Percent) + this.Rand.Range(-this.DashCooldownRand, this.DashCooldownRand);
                //deal damage to player
                var damage = Damage();
                damage.Damage = this.DashDamage;
                damage.DeathMSG = this.DashDamageMSG;
                GlobalVariables.Player.DispatchEvent(Events.Damage, damage);
                
            } else {                                            //run into wall
                
                //set state to dazed
                this.State = RState.Dazed;
                //set timer for dazed state
                this.Timer = this.DazeTime;
                
            }
        }
    }

    function OnLogicUpdate(event : UpdateEvent) {
        
        //prevent all damage
        this.Health.Locked = true;
        
        //run current state
        if (this.State == RState.Idle) {
            this.Idle(event.Dt);
        } else if (this.State == RState.Normal) {
            this.Normal(event.Dt);
        } else if (this.State == RState.Rush) {
            this.Rush(event.Dt);
        } else if (this.State == RState.AngryRush) {
            this.AngryRush(event.Dt);
        } else if (this.State == RState.Dazed) {
            this.Dazed(event.Dt);
        } else if (this.State == RState.Winding) {
            this.Wind(event.Dt);
        }
        
    }
    
    //*****State Functions*****
    
    //pre boss fight, wait until player gets close
    function Idle (dt : Real) {
        this.RigidBody.Velocity = Real3(0);
        
        if(Math.Distance(this.Owner.Transform.WorldTranslation, GlobalVariables.Player.Transform.WorldTranslation) <= this.StartRange) {
            //set state to normal
            this.State = RState.Normal;
            //set timer for dash cooldown
            this.Timer = Math.Lerp(this.DashCooldownMin, this.DashCooldownMax, this.Health.Percent) + this.Rand.Range(-this.DashCooldownRand, this.DashCooldownRand);
        }
    }
    
    //follow the player around slowly
    function Normal (dt : Real) {
        //go towards player
        this.PathFollow.SetTarget(GlobalVariables.Player.Transform.WorldTranslation);
        this.RigidBody.Velocity *= this.MovSpeed;
        
        //count down to wind timer
        this.Timer -= dt;
        
        //go to wind state
        if (this.Timer <= 0) {
            
            this.State = RState.Winding;
            
            //set wind timer
            this.Timer = Math.Lerp(this.WindUpTimeMin, this.WindUpTimeMax, this.Health.Percent);
            //setup dash variables (we do this here so that enemy will dash in the direction that the player was in when the wind-up started)
            this.DashOnce = false;
            this.DashStart = this.Owner.Transform.WorldTranslation;
            this.DashDir = Math.Normalize(GlobalVariables.Player.Transform.WorldTranslation - this.Owner.Transform.WorldTranslation);
            
        }
    }
    
    //dash in the direction of the player
    function Rush (dt : Real) {
        
        //go in dash direction
        this.RigidBody.Velocity = this.DashDir * this.DashSpeed;
        
        //go back to normal when traveled far enugh
        if (Math.Distance(this.Owner.Transform.WorldTranslation, this.DashStart) > this.DashDistance) {
            
            //set state to normal
            this.State = RState.Normal;
            //setup cooldown timer
            this.Timer = Math.Lerp(this.DashCooldownMin, this.DashCooldownMax, this.Health.Percent) + this.Rand.Range(-this.DashCooldownRand, this.DashCooldownRand);
            
        }
        
    }
    
    //dash turning to the player
    function AngryRush (dt : Real) {
        
        //go in dash direction
        this.RigidBody.Velocity = this.DashDir * this.DashSpeed;
        
        //turn dash direction twards player
        var tdir = GlobalVariables.Player.Transform.WorldTranslation - this.Owner.Transform.WorldTranslation;
        var angle = Math.ATan2(this.RigidBody.Velocity.Y, this.RigidBody.Velocity.X);
        var tAngle = Math.ATan2(tdir.Y, tdir.X);
        var a = Math.ATan2(Math.Sin(tAngle-angle), Math.Cos(tAngle-angle));
        
        if(Math.ToDegrees(a) > 180) {
            a -= Math.ToRadians(360);
        }
        
        if(Math.ToDegrees(a) < -180) {
            a += Math.ToRadians(360);
        }
        
        if(Math.Abs(a - angle) < this.AngryTurnSpeed*dt)
            angle = tAngle;
        else if(a > 0) {
            angle += Math.ToRadians(this.AngryTurnSpeed)*dt;
        } else {
            angle += -Math.ToRadians(this.AngryTurnSpeed)*dt;
        }
        
        this.DashDir = Real3(Math.Cos(angle), Math.Sin(angle), 0);
        
        //go back to normal when chasing for long enugh
        this.Timer -= dt;
        if (this.Timer <= 0) {
            
            //set state to normal
            this.State = RState.Normal;
            //setup cooldown timer
            this.Timer = Math.Lerp(this.DashCooldownMin, this.DashCooldownMax, this.Health.Percent) + this.Rand.Range(-this.DashCooldownRand, this.DashCooldownRand);
            
        }
        
    }
    
    //sit there dazed, this is the only time when the player can deal damage
    function Dazed (dt : Real) {
        
        //allow damage when dazed
        this.Health.Locked = false;
        
        //dont move when dazed
        this.RigidBody.Velocity = Real3(0);
        
        //sit still until no longer dazer
        this.Timer -= dt;
        if (this.Timer <= 0) {
            
            //set state to normal
            this.State = RState.Normal;
            //setup cooldown timer
            this.Timer = Math.Lerp(this.DashCooldownMin, this.DashCooldownMax, this.Health.Percent) + this.Rand.Range(-this.DashCooldownRand, this.DashCooldownRand);
            
        }
        
    }
    
    //wind up before rushing
    function Wind (dt : Real) {
        
        //wait until done winding up
        this.Timer -= dt;
        
        //dont move while winding
        this.RigidBody.Velocity = Real3(0);
        this.PathFind.Path = null;
        
        if (this.Timer <= 0) {
            
            //set to dash if over angry dash health, otherwise set to angry dash
            if (this.Health.Percent < this.AngryDashHealth) {
                
                //set state to angry dash
                this.State = RState.AngryRush;
                //set up timer for angry dash
                this.Timer = this.AngryDashTime;
                
            } else {
                
                //set state to dash
                this.State = RState.Rush;
                
            }
        }
    }
    
}
