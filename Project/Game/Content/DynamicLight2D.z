struct POI {
    var Null : Boolean = false;
    var X : Real;
    var Y : Real;
    var Param: Real;
    
    constructor (isNull : Boolean) {
        this.Null = isNull;
    }
    constructor (x : Real, y : Real, param : Real) {
        this.X = x;
        this.Y = y;
        this.Param = param;
        this.Null = false;
    }
}

class DynamicLight2D : ZilchComponent
{
    
    var Mesh : Mesh;
    
    var Points : Array[PointReturn];
    
    function Initialize(init : CogInitializer) {
        Zero.Connect(this.Space, Events.LogicUpdate, this.OnLogicUpdate);
        this.Points = Array[PointReturn]();
    }

    function OnLogicUpdate(event : UpdateEvent) {
        
        //this.Owner.Parent.Transform.WorldTranslation = this.LevelSettings.CameraViewport.ScreenToWorldZPlane(Zero.Mouse.ScreenPosition, 0);
        
        var segments = Array[Segment]();
        var pos = this.Owner.Transform.WorldTranslation;
        
        var camViewPort = this.LevelSettings.CameraViewport;
        
        //edge of screen bounds
        var top     = Segment(pos + Real3(20, 20, 0), Real3(-20, 20, 0));
        var bottom  = Segment(pos + Real3(20, -20, 0), Real3(-20, -20, 0));
        var left    = Segment(pos + Real3(20, 20, 0), Real3(20, -20, 0));
        var right   = Segment(pos + Real3(-20, 20, 0), Real3(-20, -20, 0));
        
        segments.Add(top);
        segments.Add(bottom);
        segments.Add(left);
        segments.Add(right);
        
        var objs = this.Space.FindAllObjectsByName("Sprite");
        
        
        
        var dm = this.Owner.DynamicMesh;
        
        foreach (var obj in objs){
            foreach (var seg in obj.Cast2DDynamicShadow.Segments){
                segments.Add(seg);
            }
        }
        
        foreach (var seg in segments){
            Utilities.DrawLine(seg.P1, seg.P2, Real4(0, 1, 0, 1));
        }
        
        var ray = Segment(Real3(0,0,0), this.LevelSettings.CameraViewport.ScreenToWorldZPlane(Zero.Mouse.ScreenPosition, 0));
        
        
        var closestIntersect = POI(true);
        for(var i = 0; i < segments.Count; ++i){
            var intersect = this.GetIntersection(ray, segments[i]);
            if(intersect.Null)
                continue;
            
            if(closestIntersect.Null || intersect.Param<closestIntersect.Param) {
                closestIntersect=intersect;
            }
        }
        var intersect = closestIntersect;
        
        Utilities.DrawLine(Real3(0,0,0), Real3(intersect.X, intersect.Y, 0), Real4(0,0,1,1));
        Utilities.DrawCircle(Real3(intersect.X, intersect.Y, 0), 0.1, true, Real4(1,0,0,1));
        
        /*this.Points.Clear();
        
        this.Points.Add(Utilities.RaycastPoint(pos, (pos + Real3( 0.51,    0.51, 0)), this.Space.PhysicsSpace, 10));
        this.Points.Add(Utilities.RaycastPoint(pos, (pos + Real3(-0.51,    0.51, 0)), this.Space.PhysicsSpace, 10));
        this.Points.Add(Utilities.RaycastPoint(pos, (pos + Real3( 0.51,   -0.51, 0)), this.Space.PhysicsSpace, 10));
        this.Points.Add(Utilities.RaycastPoint(pos, (pos + Real3(-0.51,   -0.51, 0)), this.Space.PhysicsSpace, 10));
        this.Points[0].Target = Real3(9999);
        this.Points[1].Target = Real3(9999);
        this.Points[2].Target = Real3(9999);
        this.Points[3].Target = Real3(9999);
        
        while(objs.IsNotEmpty){
            var current = objs.Current;
            //for(var i = 0; i < 4; ++i){
                
            //}
            this.Points.Add(Utilities.RaycastPoint(pos, (current.Transform.WorldTranslation + Real3( 0.51,    0.51, 0)), this.Space.PhysicsSpace, 10));
            this.Points.Add(Utilities.RaycastPoint(pos, (current.Transform.WorldTranslation + Real3(-0.51,    0.51, 0)), this.Space.PhysicsSpace, 10));
            this.Points.Add(Utilities.RaycastPoint(pos, (current.Transform.WorldTranslation + Real3( 0.51,   -0.51, 0)), this.Space.PhysicsSpace, 10));
            this.Points.Add(Utilities.RaycastPoint(pos, (current.Transform.WorldTranslation + Real3(-0.51,   -0.51, 0)), this.Space.PhysicsSpace, 10));
            
            objs.MoveNext();
        }
        
        for (var i = 0; i < this.Points.Count; ++i) {
            if(this.Points[i].Pos == Real3(9999)) {
                this.Points.RemoveAt(i);
                --i;
            } else if (this.Points[i].Target == this.Points[i].Pos) {
                this.Points[i].Pos = Real3(9999);
            }
        }
        
        var lastAngle : Real = -999;
        
        
        dm.Clear();
        
        dm.AddVertex(Real3(0,0,0));
        for (var i = 0; i < this.Points.Count; ++i){
            
            var a : Real = 999;
            var aIndex = 0;
            
            for (var l = 0; l < this.Points.Count; ++l){
                var angle = Math.ATan2(((this.Points[l].Pos + Real3(0.51, 0.51, 0)) - pos).Y, ((this.Points[l].Pos + Real3(0.51, 0.51, 0)) - pos).X);
                if(angle > lastAngle && angle < a){
                    a = angle;
                    aIndex = l;
                }
            }
            
            
            Utilities.DrawCircle(this.Points[aIndex].Pos, 0.05 * (i+1), true, Real4(1, 0, 0, 1));
            
            dm.AddVertex(this.Points[aIndex].Pos - pos);
            
            lastAngle = a;
        }
        
        //Console.WriteLine("--------------------------------------------");
        
        for (var i = 1; i < dm.VertexCount; ++i){
            
            //Console.WriteLine("hi");
            
            dm.AddTriangleIndices(i, i+1, 0);
            
        }
        
        dm.AddTriangleIndices(dm.VertexCount-1, 1, 0);*/

        dm.AddUV(Real2(1,1));
        
        dm.Modified();
        
    }
    
    /*function SortCompare (left : PointReturn, right : PointReturn) : Boolean{
        var pos = this.Owner.Transform.WorldTranslation;
        return Math.ATan2(((left.Pos + Real3(0.51, 0.51, 0)) - pos).Y, ((left.Pos + Real3(0.51, 0.51, 0)) - pos).X) > Math.ATan2(((right.Pos + Real3(0.51, 0.51, 0)) - pos).Y, ((right.Pos + Real3(0.51, 0.51, 0)) - pos).X);
    }*/
    
    function GetIntersection (ray : Segment, segment : Segment) : POI {
        
        var r_px = ray.P1.X;
        var r_py = ray.P1.Y;
        var r_dx = ray.P2.X - ray.P1.X;
        var r_dy = ray.P2.Y - ray.P1.Y;
        
        var s_px = segment.P1.X;
        var s_py = segment.P1.Y;
        var s_dx = segment.P2.X - segment.P1.X;
        var s_dy = segment.P2.Y - segment.P1.Y;
        
        var r_mag = Math.Sqrt(r_dx*r_dx+r_dy*r_dy);
        var s_mag = Math.Sqrt(s_dx*s_dx+s_dy*s_dy);
        if(r_dx/r_mag == s_dx/s_mag && r_dy/r_mag == s_dy/s_mag)
            return POI(true);
        
        if((s_dx*r_dy - s_dy*r_dx) == 0)
            return POI(true);
        
        var t2 = (r_dx*(s_py-r_py) + r_dy*(r_px-s_px))/(s_dx*r_dy - s_dy*r_dx);
        var t1 = (s_px+s_dx*t2-r_px)/r_dx;
        
        if(t1<0)
            return POI(true);
        if(t2<0 || t2>1)
            return POI(true);
        
        return POI(r_px+r_dx*t1, r_py+r_dy*t1, t1);
        
    }
    
}
